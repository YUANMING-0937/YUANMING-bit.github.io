<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Python/GIL锁  进程线程 | 渊明</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://yuanming-bit.github.io/favicon.ico?v=1630465397762">
<link rel="stylesheet" href="https://yuanming-bit.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="在讲GIL锁之前先聊一下进程线程之间的关系
进程线程

进程
进程是资源分配的的最小单位，开辟自己的地址空间执行的是一段程序，一个进程可以包含多个线程，进程之间不会相互影响，进程间不方便交换数据，进程的性能开销比较大。
线程
线程是CPU调..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://yuanming-bit.github.io">
        <img src="https://yuanming-bit.github.io/images/avatar.png?v=1630465397762" class="site-logo">
        <h1 class="site-title">渊明</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      总是在安静的时候想得很多然后难受很久 。 
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://yuanming-bit.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Python/GIL锁  进程线程</h2>
            <div class="post-date">2021-09-01</div>
            
            <div class="post-content" v-pre>
              <p>在讲GIL锁之前先聊一下进程线程之间的关系</p>
<h3 id="进程线程">进程线程</h3>
<ul>
<li>进程<br>
<strong>进程是资源分配的的最小单位</strong>，开辟自己的地址空间执行的是一段程序，一个进程可以包含多个线程，进程之间不会相互影响，进程间不方便交换数据，进程的性能开销比较大。</li>
<li>线程<br>
<strong>线程是CPU调度的最小单位</strong>，线程地址包含在进程地址空间中执行的是进程下发的任务，一个线程只从属一个进程，线程影响所属进程，同一进程下线程间数据共享，线程性能开销比较小。</li>
</ul>
<p><strong>举例说明就如同火车与车厢的从属关系，进程就相当于火车、线程就是车厢，资源占用度取决于挂载的车厢数量，多列火车之间不会相互影响，某列火车上一节车厢坏掉了，整列火车都不能运行了，数据交换以列车物资交换举例，同列火车车厢间交换物资比多列火车之间交换物资更加方便快捷。</strong></p>
<h3 id="pythongil锁">Python/GIL锁</h3>
<p><strong>Python/GIL锁</strong>锁的是CPU上的内核，上面讲过<strong>线程是CPU调度的最小单位</strong>，即线程是运行在CPU上在CPU的内核上执行的，Python/GIL锁是控制多线程非并发的执行。保证多线程在内核上执行的唯一性。</p>
<p><strong>Python/GIL锁的认识</strong></p>
<ul>
<li>保证安全<br>
上面讲到多线程之间的数据共享，当多线程同时对数据进行io时，不能确保某线程io是否执行完毕就有新的线程进行io无法保证数据正确，就会造成数据混乱，<strong>扩展理解Mysql的事务</strong> Python/GIL锁确保了某线程io执行结束或者超过Time Tick后才可以执行其他线程。</li>
<li>多核性能无法满载<br>
由于Python/GIL锁为了确保安全，锁的是所有内核，以确保同一时刻只有一个线程通过内核通道正常io，多核上的线程存在等待过程，所以多核性能无法满载。</li>
</ul>
<p><strong>超过Time Tick</strong>  当前线程退回，并重新开始竞争，退回并重新竞争过程中其它核只能观望。</p>
<p>tread1 内核1 tread2 内核2 tread3，当只有内核1时，tread1、tread2、tread3共同竞争通过内核1的机会，tread1竞争到了，tread2、tread3等待tread1 io结束或者超过Time Tick，tread1 io正常结束tread2、tread3竞争执行，tread1 io超过Time Tick结束tread1、tread2、tread3重新竞争执行，可以让单核性能满载。<br>
tread1，tread3运行在内核1上tread2运行在内核2上，tread1，tread3竞争通过内核1的机会，tread1竞争到了，tread2、tread3等待tread1 io结束或者超过Time Tick，tread1 io正常结束tread2在内核2上执行、tread3在内核1上执行，tread1 io超过Time Tick结束，tread1、tread3又要重新竞争执行，当tread1又抢到了内核1上的执行机会，内核2上的tread2也只能干看着不能动，因为内核1上的某线程还没执行结束。</p>
<p><strong>为了避免同一线程霸占CPU，在python3.x中，线程会自动的调整自己的优先级，使得多线程任务执行效率更高。</strong></p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://yuanming-bit.github.io/post/tcpip-san-wo-si-hui/">
                  <h3 class="post-title">
                    TCP/IP协议  三次握手与四次挥手
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
